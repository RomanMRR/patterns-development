package main

import "fmt"

/*
	Реализовать паттерн «фабричный метод».
Объяснить применимость паттерна, его плюсы и минусы, а также реальные примеры использования данного примера на практике.
	https://en.wikipedia.org/wiki/Factory_method_pattern

		ПЛЮСЫ
	 Избавляет класс от привязки к конкретным классам продуктов.
	Выделяет код производства продуктов в одно место, упрощая поддержку кода.
	Упрощает добавление новых продуктов в программу.
	Реализует принцип открытости/закрытости.

	МИНУСЫ
	Может привести к созданию больших параллельных иерархий классов, так как для каждого класса продукта надо создать свой подкласс создателя.

	 Применимость
	Когда заранее неизвестны типы и зависимости объектов, с которыми должен работать ваш код.
	 Когда вы хотите дать возможность пользователям расширять части вашего фреймворка или библиотеки.
	 Когда вы хотите экономить системные ресурсы, повторно используя уже созданные объекты, вместо порождения новых.

	Пример на практике
	К примеру, программа управления грузовыми перевозками. Сперва программа работает только с грузовиками, а потому весь код программы работает только
	с объектами класса Грузовики. Но если в программу добавятся морские перевозки, то придётся изменять всю программу и добавить поддержку морского
	транспорта. Благодаря паттерну можно создавать объекты через особый фабричный метод. Подклассы будут реализовывать свои фабричные методы, чтобы
	создавать требуемый объект транспорта. Все создаваемые объекты должные следовать одному и тому же интерфейсу, к примеру, объекты Грузовик и Судно реализуют
	интрефейс Транспорт с методом доставить. Каждый из этих объектов реализует этот метод по своему. Фабричный метод класса ДорожноаяЛогистика будет создавать грузовики, а
	МорскаяЛогистика будет создавать Судна и все эти объекты будут иметь метод доставки, только Грузовики доставляют по Земле, а Судно по Морю.

*/

// Интерфейс для работы с производимыми пушками
type IGun interface {
	setName(name string)
	setPower(power int)
	getName() string
	getPower() int
}

// Сам продукт, который реализует все методы интерфейса
type Gun struct {
	name  string
	power int
}

func (g *Gun) setName(name string) {
	g.name = name
}

func (g *Gun) getName() string {
	return g.name
}

func (g *Gun) setPower(power int) {
	g.power = power
}

func (g *Gun) getPower() int {
	return g.power
}

// Конкретная пушка - АК-47
type Ak47 struct {
	Gun
}

func newAk47() IGun {
	return &Ak47{
		Gun: Gun{
			name:  "AK47 gun",
			power: 4,
		},
	}
}

// Конкретная пушка - мушкет
type musket struct {
	Gun
}

func newMusket() IGun {
	return &musket{
		Gun: Gun{
			name:  "Musket gun",
			power: 1,
		},
	}
}

// Фабрика по производству пушек
func getGun(gunType string) (IGun, error) {
	if gunType == "ak47" {
		return newAk47(), nil
	}
	if gunType == "musket" {
		return newMusket(), nil
	}
	return nil, fmt.Errorf("Wrong gun type passed")
}

func main() {
	ak47, _ := getGun("ak47")
	musket, _ := getGun("musket")

	printDetails(ak47)
	printDetails(musket)
}

func printDetails(g IGun) {
	fmt.Printf("Gun: %s", g.getName())
	fmt.Println()
	fmt.Printf("Power: %d", g.getPower())
	fmt.Println()
}
